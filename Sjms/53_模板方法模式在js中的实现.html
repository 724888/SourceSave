<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script>
    var Beverage = function(param) {
        var boilWater = function() {
            console.log("把水煮沸");
        };
        var brew = param.brew || function() {
            throw new Error("必须传递brew方法");
        };
        var pourInCup = param.pourInCup || function() {
            throw new Error("必须传递pourInCup方法");
        };
        var addCondiments = param.addCondiments || function() {
            throw new Error("必须传递addCondiments方法");
        };
        var F = function() {};
        F.prototype.init = function() {
            boilWater();
            brew();
            pourInCup();
            addCondiments();
        };
        return F;
    };
    var Coffee = Beverage({
        brew: function() {
            console.log('用沸水冲泡咖啡');
        },
        pourInCup: function() {
            console.log('把咖啡倒进杯子');
        },
        addCondiments: function() {
            console.log('加糖和牛奶');
        }
    });
    var Tea = Beverage({
        brew: function() {
            console.log('用沸水浸泡茶叶');
        },
        pourInCup: function() {
            console.log('把茶倒进杯子');
        },
        addCondiments: function() {
            console.log('加柠檬');
        }
    });
    var coffee = new Coffee();
    coffee.init();
    var tea = new Tea();
    tea.init();
    // 在这段代码中，我们把brew、pourInCup、addCondiments 这些方法依次传入Beverage 函数，    Beverage 函数被调用之后返回构造器F。 F 类中包含了“ 模板方法” F.prototype.init。 跟继承得到的效果一样， 该“ 模板方法” 里依然封装了饮料子类的算法框架。
    </script>
</body>

</html>
