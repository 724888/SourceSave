<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script type="text/javascript">
    // 策略模式:定义一系列算法，把他们一个一个封装起来，并且使他们可以相互替换。策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。它将算法的实现和使用分离
    // 应用场景:当需要根据不同策略(算法)计算时
    // 使用举例:根据工资和绩效等级计算年终奖、缓动动画、表单验证，这三种都是会有多中不同的策略，如年终奖有SAB三等级3个策略，最终都是要得到年终奖。缓动动画有ease-in,ease-out...，最后是要得到一个动画。表单验证需要验证数字、邮箱...等，但最终都要得到是否验证通过这一结果。都是需要根据不同策略，得出某结果
    // 组成部分:1.一组策略类，封装了算法，并负责具体计算2.环境类Contex，负责接收请求，并把请求委托给某个具体的策略类

    // var calculateBonus = function(performanceLevel, salary) {
    //     if (performanceLevel === "S") {
    //         return salary * 4;
    //     }
    //     if (performanceLevel === "A") {
    //         return salary * 3;
    //     }
    //     if (performanceLevel === "B") {
    //         return salary * 2;
    //     }
    // };
    // console.log(calculateBonus("B", 2000)); //4000
    // console.log(calculateBonus("S", 4000)); //16000
    // 上面的缺点
    // 函数庞大，包含了很多if-else，这些要覆盖所有的逻辑分支
    // 缺乏弹性，如果要增加C等级，或修改倍数，必须进入函数内部修改
    // 算法复用性差

    // 使用组合函数重构
    var performanceS = function(salary) {
        return salary * 4;
    };
    var performanceA = function(salary) {
        return salary * 3;
    };
    var performanceB = function(salary) {
        return salary * 2;
    };
    var calculateBonus = function(performanceLevel, salary) {
        if (performanceLevel === 'S') {
            return performanceS(salary);
        }
        if (performanceLevel === 'A') {
            return performanceA(salary);
        }
        if (performanceLevel === 'B') {
            return performanceB(salary);
        }
    };
    calculateBonus('A', 10000); // 输出：30000
    // 虽然解决了算法复用，但是依旧庞大，并缺乏弹性
    </script>
</body>

</html>
