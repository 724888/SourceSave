<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <pre>
		*面向对象3大特点：封装，继承，多态*

1. 原型：集中保存所有对象公用属性*值*和方法的对象。
     每个函数都有一个属性prototype,指向自己的原型对象
     重点作用于构造函数！
     每个对象都有一个__proto__属性，执行创造自己的构造函数的原型！
   什么样的属性才会放入原型？所有对象共享的属性*值*
   什么样的方法才会放入原型？希望所有对象共有的方法

   new 构造函数(); 4步：
   1. new创建空对象
   2. 调用构造函数向新对象中添加属性和方法
   3. 设置新对象的__proto__属性指向构造函数的原型对象
   4. 返回新对象的地址给调用者

   删除属性：delete 对象.属性：删除自有属性
       delete 构造函数.prototype.属性：删除共有属性

   自有属性：直接通过对象.或构造函数创建的属性
            自有属性仅属于当前对象所有
   共有属性：通过构造函数的*原型*添加的属性
            共有属性，所有对象共享其值。

   *如何判断自有属性和共有属性：2种：*
   1. 仅检查自有属性：obj.hasOwnProperty("属性名");
       如果hasOwnProperty返回false，
   2. 检查原型链上的对象中，是否包含指定属性：
      （检查共有属性）
      语法："属性名" in 对象

原型链：由每个对象的__proto__属性连续引用形成的多级关系

   继承：父对象中的属性值或方法，子对象可直接使用。
   *js中通过修改子对象的原型为一个父对象来实现继承*
   如何设置子对象继承父对象：3种方式：
   1. 单独修改一个对象的父对象，不影响其他对象
      Object.setPrototypeOf(子对象,父对象)
   2. 直接修改构造函数的原型对象。
      不影响已创建的对象
      会影响之后新创建的对象
      语法：构造函数.prototype=父对象
   3. 创建新对象同时，手动设置父对象：
      语法：var newObj=Object.create(父对象)
      只影响正在创建的对象。

   重写：*子对象觉得父对象的方法不好用*
         自己定义同名的，但不同实现的方法

   ***扩展内置对象的公共方法***
   比如: function indexOf(arr,elem)
         var arr=[];
         //var i=indexOf(arr,4);
	 var i=arr.indexOf(4)
   再比如：var str="no zuo no die";
           var i=new String(str).indexOf("no");
   1.在内置对象类型的原型中，添加扩展方法！
   2.在方法内使用this，获得正在调用函数的对象

   作业：
   1. 扩展Date类型的format方法
      测试代码：
      console.log(new Date().format);
   2. 扩展Number类型的round方法
      测试代码：
      var n=123.456;
      console.log(n.round(2)); //123.46
      console.log(typeof(n.round(2))); //number
	</pre>
</body>

</html>
